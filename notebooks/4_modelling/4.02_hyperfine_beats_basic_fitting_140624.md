---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.14.7
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Basic fitting for hyperfine beat (stage 1 bootstrap)

From prior work and data:

- Forbes, R. et al. (2018) ‘Quantum-beat photoelectron-imaging spectroscopy of Xe in the VUV’, Physical Review A, 97(6), p. 063417. Available at: https://doi.org/10.1103/PhysRevA.97.063417. arXiv: http://arxiv.org/abs/1803.01081, Authorea (original HTML version): https://doi.org/10.22541/au.156045380.07795038
- Data (OSF): https://osf.io/ds8mk/
- [Quantum Metrology with Photoelectrons (Github repo)](https://github.com/phockett/Quantum-Metrology-with-Photoelectrons), particularly the [Alignment 3 notebook](https://github.com/phockett/Quantum-Metrology-with-Photoelectrons/blob/master/Alignment/Alignment-3.ipynb). Functions from this notebook have been incorporated in the current project, under `qbanalysis.hyperfine`.

+++

For basic fitting, try a stage 1 style bootstrap. In this case, set (arbitrary) parameters per final state for the probe, and fit these plus the hyperfine beat model parameters. This should allow for a match to a single set of hyperfine parameters for all observables.

- 14/06/24: basic fit for L=4/ROI-0 data working with Scipy. Next should add ionization model and use all states...
   - Xarray wrapper may be neater? See https://docs.xarray.dev/en/latest/generated/xarray.DataArray.curvefit.html#xarray.DataArray.curvefit
   - 16/06/24: A,B param determination with Scipy.least_squares working. Seems like overkill, but other methods not very flexible? Currently pass Xarray data for calcs, with wrappers for Scipy. Quite annoying.

+++

## Setup fitting model

Follow the modelling notebook, but wrap functions for fitting.

+++

### Imports

```{code-cell} ipython3
# Load packages
# Main functions used herein from qbanalysis.hyperfine
from qbanalysis.hyperfine import *
import numpy as np
from epsproc.sphCalc import setBLMs

from pathlib import Path

dataPath = Path('/tmp/xe_analysis')
dataTypes = ['BLMall', 'BLMerr', 'BLMerrCycle']   # Read these types, should just do dir scan here.

# # Read from HDF5/NetCDF files
# # TO FIX: this should be identical to loadFinalDataset(dataPath), but gives slightly different plots - possibly complex/real/abs confusion?
# dataDict = {}
# for item in dataTypes:
#     dataDict[item] = IO.readXarray(fileName=f'Xe_dataset_{item}.nc', filePath=dataPath.as_posix()).real
#     dataDict[item].name = item

# Read from raw data files
from qbanalysis.dataset import loadFinalDataset
dataDict = loadFinalDataset(dataPath)

# Use Pandas and load Xe local data (ODS)
# These values were detemermined from the experimental data as detailed in ref. [4].
from qbanalysis.dataset import loadXeProps
xeProps = loadXeProps()
```

### Init parameters

Here use `xeProps` to set and define fit paramters. Note in the original work the splittings were determined by FT of the data, and A, B parameters via Eqn. 2 therein.

TODO: may want to use lmfit here for more flexibility.

```{code-cell} ipython3
# Set splittings
fitParamsCol = 'Splitting/cm−1'
xePropsFit = xeProps.copy()

xeSplittings = xePropsFit[fitParamsCol].to_numpy()
```

```{code-cell} ipython3
# Test beat model with changed params...
xeSplittings = np.random.randn(4)
xeSplittings
```

```{code-cell} ipython3
xePropsFit[fitParamsCol] = 0.1*np.abs(xeSplittings)
xePropsFit
```

```{code-cell} ipython3
modelDict = computeModel(xePropsFit)
modelSum = computeModelSum(modelDict)['sum'] 
plotOpts = {'width':800}
(plotHyperfineModel(modelDict['129Xe'], **plotOpts) * plotHyperfineModel(modelDict['131Xe'], **plotOpts) * plotHyperfineModel(modelSum, **plotOpts)).opts(title="Isotope comparison + sum")
```

```{code-cell} ipython3
# Test with ROI 0, l=4 case first...
dataDict['BLMall'].sel({'ROI':0,'l':4}).squeeze().hvplot()  #.line(x='t')
```

```{code-cell} ipython3
def residual(model,dataIn):
    """
    Calc least squares residual
    """
    res = (model - dataIn)**2  # Returning single value XR only in testing? Issue with dims?
                            # Ah, OK after fixing t-units
    # res = model.values - dataIn.values  # Force to NP, assumes matching size.

    return res

def setParams(xePropsIn, newVals, fitParamsCol = 'Splitting/cm−1'):
    """
    Replace single column in input dataframe with newVals.
    
    Note: no size checks here.
    """
    
    # Set splittings
    # fitParamsCol = 'Splitting/cm−1'
    xePropsUpdated = xePropsIn.copy()
    xePropsUpdated[fitParamsCol] = newVals
    
    return xePropsUpdated

# NOTE - setting trange here may be required.
# Fitting to full window tends to smooth out oscillations, may need to be more careful with residual func?
# trange=[0,200]  OK first part only
# trange=[0,500]  GOOD!
# trange=[0,800]  GOOD! Lower overall intensity than [0,500] case.
# trange=[0,1000]  GOOD! Lower overall intensity than [0,500] case.
# trange=None  OK, but t<0 data messes things up a bit.
def calcFitModel(xData, xePropsFit = None, dataDict = None, fitFlag=True, trange=[0,1000]):
    """
    Calc model and residual for Scipy fitting.
    
    Set fitFlag=False to return all model results.
    """
    
    # Update fit params
    xePropsFit = setParams(xePropsFit,xData)
    
    # Compute model
    modelDict = computeModel(xePropsFit, tIn=dataDict['BLMall'].t*1e-12)  # Note t-units in s!
    modelSum = computeModelSum(modelDict)['sum'] 

    # Compute residual
    dataIn = dataDict['BLMall'].sel({'ROI':0,'l':4}).copy()
    modelIn = modelSum.sel({'K':2}).squeeze(drop=True)
    # modelIn.values = unumpy.nominal_values(modelIn)  # Use nominal values only?
    # modelIn['t'].values = modelIn['t'].values.astype(int) 
    modelIn = modelIn.assign_coords({'t':modelIn['t'].values.astype(int)})  # Force to int to match input data

    # Optionally set trange
    if trange is not None:
        modelIn = modelIn.sel(t=slice(trange[0],trange[1]))
        dataIn = dataIn.sel(t=slice(trange[0],trange[1]))
    
    res = residual(modelIn, dataIn.squeeze())
    
    if fitFlag:
        return unumpy.nominal_values(res.values)
    else:
        
        # Fix splitting value for 1.5,2.5 (derived case)
        # TODO: this is inconsistent with fitting later?
        iso=131
        xePropsFit.loc[(iso,1.5,2.5,1.5), dataCol] = xePropsFit.loc[(iso,1.5,2.5,0.5), dataCol] - xePropsFit.loc[(iso,1.5,1.5,0.5), dataCol]
        
        return xePropsFit, modelDict, modelSum, modelIn, dataIn, res

    
def compareResults(xeProps, xePropsFit, fitParamsCol = 'Splitting/cm−1'):
    """
    Create comparison table of reference and fit results.
    """
    
    import pandas as pd
    
    diffData = pd.DataFrame([xeProps[fitParamsCol], xePropsFit[fitParamsCol], xeProps[fitParamsCol]-xePropsFit[fitParamsCol]]).T
    # diffData.columns.rename({n:item for n,item in enumerate(['original','fit','diff'])})
    diffData.columns = ['original','fit','diff']
    
    # Remove uncertainties? Makes sense if comparing diffs from different anlyses
    diffData['diff']= unumpy.nominal_values(diffData['diff'].values)
    
    return diffData

def extractABParams():
    """
    Determine A & B parameters from hyperfine level splittings. 
    """
    
    pass

    
# Test fit...

# Fit to residuals, just set to zero (NOT required for least_squares)
yData = xr.zeros_like(dataDict['BLMall'].sel({'ROI':0,'l':4}))
yData = yData.values

import scipy
# x0 = np.abs(np.random.random(4))  # Randomise inputs

xePropsFit = xeProps.copy()
x0 = unumpy.nominal_values(xePropsFit[fitParamsCol].to_numpy())  # Test with previous vals

fitOut = scipy.optimize.least_squares(calcFitModel, x0, bounds = (0.01,0.5),
                                      kwargs = {'xePropsFit':xePropsFit, 'dataDict':dataDict})
fitOut.success
```

```{code-cell} ipython3
# Using Scipy, the fit details are in fitOut, and results in fitOut.x
fitOut.x
```

```{code-cell} ipython3
fitOut
```

```{code-cell} ipython3
# Check results - run model again with best fits
xePropsFit, modelFit, modelFitSum, modelIn, dataIn, res = calcFitModel(fitOut.x, xePropsFit, dataDict, fitFlag=False)

# # Fix splitting value (derived) - NOW IN MAIN ROUTINE
# iso=131
# xePropsFit.loc[(iso,1.5,2.5,1.5), dataCol] = xePropsFit.loc[(iso,1.5,2.5,0.5), dataCol] - xePropsFit.loc[(iso,1.5,1.5,0.5), dataCol]
# xePropsFit

# Fitted model & components
(plotHyperfineModel(modelFit['129Xe'], **plotOpts) * plotHyperfineModel(modelFit['131Xe'], **plotOpts) * plotHyperfineModel(modelFitSum, **plotOpts)).opts(title="Isotope comparison + sum")
```

```{code-cell} ipython3
# Compare fit results with dataset
from qbanalysis.plots import plotFinalDatasetBLMt
# plotFinalDatasetBLMt(**dataDict, **plotOpts) * plotHyperfineModel(modelFitSum, **plotOpts).select(K=2).opts(**plotOpts)
plotHyperfineModel(modelFitSum, **plotOpts).select(K=2).opts(**plotOpts) * plotFinalDatasetBLMt(**dataDict, **plotOpts)
```

```{code-cell} ipython3
# Check new results vs. reference case...
compareResults(xeProps, xePropsFit)
```

```{code-cell} ipython3
xePropsFit
```

```{code-cell} ipython3
# # Fix splitting value (derived) - NOW IN MAIN ROUTINE
# iso=131
# xePropsFit.loc[(iso,1.5,2.5,1.5), dataCol] = xePropsFit.loc[(iso,1.5,2.5,0.5), dataCol] - xePropsFit.loc[(iso,1.5,1.5,0.5), dataCol]
# xePropsFit
```

### Determine A & B parameters

Previously fitted in Matlab with cffit tool, see `jake-home/tmp/xe_analysis_2024_scratch/Xe_hyperfine_cftool_fit_code_041217.m`.

+++

From the measurements, the hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
\begin{equation}
\Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
\end{equation}

Note, for $^{129}\rm{Xe}$, $\Delta E_{(F,F-1)}=AF$ only ($B=0$).

+++

### Quick test with sklearn (linear)

```{code-cell} ipython3
# Xe129, dE(F,F-1)=AF
# xePropsFit[[xePropsFit.xs((129)),'A/MHz']]  #['A/MHz']= 30

cmToMHz = 29979.2458
dataCol = 'Splitting/cm−1'
qnDF = xePropsFit.loc[(129)].index.to_frame()  # Convert to DF for easy Q.N./index value retrieval
xePropsFit.loc[(129), 'A/MHz'] = (xePropsFit.loc[(129), dataCol]/qnDF['F′']).values * cmToMHz
xePropsFit                                                                                                         
```

```{code-cell} ipython3
xePropsFit.xs(131)[dataCol]
```

```{code-cell} ipython3
xePropsFit.xs(iso)[dataCol].to_numpy()
```

```{code-cell} ipython3
qnDF['F'].to_numpy()
```

```{code-cell} ipython3
# Xe131
iso=131
qnDF = xePropsFit.loc[(iso)].index.to_frame()  # Convert to DF for easy Q.N./index value retrieval

# Fix splitting value (derived)
xePropsFit.loc[(iso,1.5,2.5,1.5), dataCol] = xePropsFit.loc[(iso,1.5,2.5,0.5), dataCol] - xePropsFit.loc[(iso,1.5,1.5,0.5), dataCol]
xePropsFit


# Quick test with linear regression
# https://realpython.com/linear-regression-in-python/
# Probably want scipy.curve_fit here though, with function defined.
from sklearn.linear_model import LinearRegression
model = LinearRegression()

# Quick test, only need 2 of these values, but should be more careful here...!
x=qnDF['F'][0:2].to_numpy().reshape(-1,1)
y=xePropsFit.xs(iso)[dataCol][0:2].to_numpy()
model.fit(x,y)
r_sq = model.score(x, y)
print(f"coefficient of determination: {r_sq}")
print(f"intercept: {model.intercept_}")
print(f"slope: {model.coef_}")

# TODO: check old work for method (not in Matlab code...?)
# TODO: other methods? Scipy or Xarray...?
# https://docs.xarray.dev/en/latest/generated/xarray.DataArray.curvefit.html#xarray.DataArray.curvefit
```

### Use Xarray wrapper - should be easier... V2: extract from PD, then XR

```{code-cell} ipython3
# xeData = xePropsFit.to_xarray()

# xePropsFit.s
dataCol = 'Splitting/cm−1'
xePropsFit.xs(131)[dataCol]
# unstack .to_xarray()
```

```{code-cell} ipython3
# dEXR.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}]
```

```{code-cell} ipython3
# NEW APPROACH - set up specific DA for fitting...
# THIS will return required vals only.
xeSubSel = xePropsFit.xs(131)[dataCol][0:2].droplevel('F′').to_xarray()  # for f' too?
A = xePropsFit.xs(131)['A/MHz'][0:2].droplevel('F′').to_xarray()
B = xePropsFit.xs(131)['B/MHz'][0:2].droplevel('F′').to_xarray()

dESubSel = dEv2(xeSubSel,A,B)
dESubSel
```

```{code-cell} ipython3
xeSubSel.squeeze().hvplot()
```

```{code-cell} ipython3
xeSubSel.squeeze() - dESubSel
```

```{code-cell} ipython3
# With Scipy wrapper... test return OK...
print(dEv2WrapperScipy([2000,0],xeDataIn=xeSubSel))
print(dEv2WrapperScipy([1697,0],xeDataIn=xeSubSel))
print(dEv2WrapperScipy([1697,-8],xeDataIn=xeSubSel))
```

```{code-cell} ipython3
# # Ah, can't pass additional args to curvefit in any case...????
# dsFit = dESubSel.curvefit(

#     coords=dESubSel.F,
    
#     # reduce_dims="I",

#     func=dEv2Wrapper,

#     bounds={"A": (1000, 2000), "B": (-15, 15)},
    
#     param_names=["A","B"],
    
#     kwargs={'xeDataIn':dESubSel}

# )

# USE WRAPPER FOR SCIPY DIRECTLY... WORKING...
#
# Defaults give [1718.15579161,   -2.19752871], [1663.67627212,    4.42848128], [ 1.69247409e+03, -1.49524345e-01]
# Seems more dependent on x0in than tolerances...? Could do with more points?
# Sets B to ~0 if bounded at 0, so -ve definitely good it seems, although not well defined?
#
# UPDATE: had mixed new and old values... now fixed...
#  [1729.31918052,   37.13028214]  # Seems pretty consistent vs. x0in.
#
# x0in = [2000,0]
# x0in = [1500, 0]
x0in = np.random.rand(2)

fitOut = scipy.optimize.least_squares(dEv2WrapperScipy, x0in, bounds = ([0,-100],[2500,100]),
                                      kwargs = {'xeDataIn':xeSubSel},
                                      verbose = 2,
                                      xtol=1e-12,ftol=1e-12,gtol=1e-18)
```

```{code-cell} ipython3
fitOut
```

```{code-cell} ipython3
fitOut.x
```

```{code-cell} ipython3
# V2, testing subselected PD array > Xr
# Calculate dE for Xarray input - in this case all coords should match in size...
# A,B can be Xarray or scalar
# def dEv2(xeDataIn, A, B, units = 'cm-1'):
def dEv2(xeDataIn, A, B):
    """
    the hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
    \begin{equation}
    \Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
    \end{equation}
    
    NOTE: units currently set for return values only.
    """
    # for iso in xeData.Isotope:
    #     print(item)
    units = 'cm-1'
    cmToMHz = 29979.2458
    
    # Isotope terms
    J=1
    I=xeDataIn.I
    c1=0.5-J*(J+1)-I*(I+1)
    c2=I*J*(2*J-1)*(2*I-1)
    
    # A/B terms
    F = xeDataIn.F
    # F = xeData['F′']  # TODO: fix 129 ordering, needs F,F' swapped! (Or enforce selection here...)
                        # Or swap on max value, or unique values... 
                        # Or check on dF, xeData.F - xeData['F′'] ...?
    # This works, but have some redundant values still
    # Ffixed = xr.where(xeData.F > xeData['F′'], xeData.F, xeData['F′'])  # Check greater
    # F = Ffixed[:,1]
    
    # Try unique vals only... Breaks 129 case...
    # F = xeData.F.where(xeData.F > 1)
    
    # Deltas... filter on these at return?
    # dF = xeData.F - xeData['F′']
    
    
    t1 = A*F  #* np.sign(dF)
    
    # For Xr case avoid Nan propagation
    if isinstance(B, xr.DataArray):
        if unFlag:
            B = xrUnFillna(B)
        else:
            B = B.fillna(0)
        
        
    t2 = (3/2)*B*((F**2 + c1)/c2)
    t2 = t2.fillna(0)
    
    # return t1,t2,t1+t2
    
    if units == 'MHz':
        dEout = t1+t2
    elif units == 'cm-1':
        dEout = (t1+t2)*(1/cmToMHz)

    # Check allowed terms...?
    # dEout = dEout.where(np.abs(dF)<2,np.nan)
        
        
    # TODO: general fix for F-F' > 1..?
    # dEXR.where(dEXR.F - dEXR['F′'] > 1)
    # Quick fix here for Xe131 case only
    # dEout.sel({'F':
    # dEout.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}] = dEout.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEout.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
    
    if unFlag:
        dEout.values = unumpy.nominal_values(dEout)
        
    return dEout


def dEv2Wrapper(xeDataInNP, A, B, xeDataIn):
    """
    Thin wrapper for xr.curvefit.
    
    Just swap NP data as passed for XR data to use existing function
    """
    
    dEOut = dEv2(xeDataIn, A, B)
    
    return dEout

    
def dEv2WrapperScipy(x0,xeDataIn=None):
    """
    ... and wrap for Scipy least_squares...
    """
    
    dEOut = dEv2(xeDataIn, x0[0], x0[1])
    
    res = ((xeDataIn - dEOut)**2).squeeze()
    
    return res.values

    
def xrUnFillna(xrData):
    """
    Implement xr.fillna for Uncertainties data types.
    """
    
    return xrData.where(~unumpy.isnan(xrData),0)
```

### Use Xarray wrapper - should be easier... V1: pure Xr, lots of redun

```{code-cell} ipython3
xeData = xePropsFit.to_xarray()
xeData
```

```{code-cell} ipython3
xeData.F
```

```{code-cell} ipython3
# V1, assumes full PD array > Xr
# Calculate dE for Xarray input - in this case all coords should match in size...
# A,B can be Xarray or scalar
def dE(xeDataIn, A, B, units = 'cm-1'):
    """
    the hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
    \begin{equation}
    \Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
    \end{equation}
    
    NOTE: units currently set for return values only.
    """
    # for iso in xeData.Isotope:
    #     print(item)
    cmToMHz = 29979.2458
    
    # Isotope terms
    J=1
    I=xeDataIn.I
    c1=0.5-J*(J+1)-I*(I+1)
    c2=I*J*(2*J-1)*(2*I-1)
    
    # A/B terms
    # F = xeDataIn.F
    # F = xeData['F′']  # TODO: fix 129 ordering, needs F,F' swapped! (Or enforce selection here...)
                        # Or swap on max value, or unique values... 
                        # Or check on dF, xeData.F - xeData['F′'] ...?
    # This works, but have some redundant values still
    Ffixed = xr.where(xeData.F > xeData['F′'], xeData.F, xeData['F′'])  # Check greater
    F = Ffixed[:,1]
    
    # Try unique vals only... Breaks 129 case...
    # F = xeData.F.where(xeData.F > 1)
    
    # Deltas... filter on these at return?
    dF = xeData.F - xeData['F′']
    
    
    t1 = A*F* np.sign(dF)
    
    # For Xr case avoid Nan propagation
    if isinstance(B, xr.DataArray):
        if unFlag:
            B = xrUnFillna(B)
        else:
            B = B.fillna(0)
        
        
    t2 = (3/2)*B*((F**2 + c1)/c2)
    t2 = t2.fillna(0)
    
    # return t1,t2,t1+t2
    
    if units == 'MHz':
        dEout = t1+t2
    elif units == 'cm-1':
        dEout = (t1+t2)*(1/cmToMHz)

    # Check allowed terms...?
    dEout = dEout.where(np.abs(dF)<2,np.nan)
        
        
    # TODO: general fix for F-F' > 1..?
    # dEXR.where(dEXR.F - dEXR['F′'] > 1)
    # Quick fix here for Xe131 case only
    # dEout.sel({'F':
    # dEout.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}] = dEout.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEout.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
    
    
    return dEout

def xrUnFillna(xrData):
    """
    Implement xr.fillna for Uncertainties data types.
    """
    
    return xrData.where(~unumpy.isnan(xrData),0)
```

```{code-cell} ipython3
Ffixed = xr.where(xeData.F > xeData['F′'], xeData.F, xeData['F′'])
Ffixed[:,1]
```

```{code-cell} ipython3
xeData.F.where(xeData.F > 1)
```

```{code-cell} ipython3
dF = xeData.F - xeData['F′']
xeData.where(np.abs(dF)<2,0)
dF
```

```{code-cell} ipython3
xeData.F
```

```{code-cell} ipython3
dE(xeData,3,10)
```

```{code-cell} ipython3
isinstance(xeData['B/MHz'], xr.DataArray)
```

```{code-cell} ipython3
dEXR = dE(xeData, xeData['A/MHz'], xeData['B/MHz'])

dEXR  #.sel(Isotope=129)
```

```{code-cell} ipython3
# Reduce to only required dim for fitting...
dEsub = dEXR.loc[{'Isotope':131,'F':[1.5,2.5],'I':1.5}]  #.dropna()

# dEsub.hvplot.line(x='F')
```

```{code-cell} ipython3
# dEXR.sel({'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}) = dEXR.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEXR.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
dEXR.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}] = dEXR.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEXR.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
```

```{code-cell} ipython3
dEXR.loc[{'Isotope':131, 'I':1.5}].drop('F′')
```

```{code-cell} ipython3
Ffixed
```

```{code-cell} ipython3
dEXR.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}]
```

```{code-cell} ipython3
dEXR.sel({'Isotope':131,'I':1.5},drop=True) #.flatten()  #.dropna()
```

```{code-cell} ipython3
dEXR.where(dEXR.F - dEXR['F′'] > 1)
```

```{code-cell} ipython3
dE(xeData,0,0)
```

```{code-cell} ipython3
F = xeData.F
xeData['A/MHz'] * F
```

```{code-cell} ipython3
B = xeData['B/MHz']

J=1
I=xeData.I
c1=0.5-J*(J+1)-I*(I+1)
c2=I*J*(2*J-1)*(2*I-1)

# For Xr case avoid Nan propagation
if isinstance(B, xr.DataArray):
    B = B.fillna(0)

t2 = (3/2)*B*((F**2 + c1)/c2)
t2 = t2.fillna(0)
t2
```

```{code-cell} ipython3
# B
# uncertainties.umath.isnan(B)
unumpy.nominal_values(B)
```

```{code-cell} ipython3
xeData.sel(Isotope=131)['F']
```

```{code-cell} ipython3
xeData.where(F>0.5)
```

```{code-cell} ipython3
xeData.sel(Isotope=129)['F′']
```

```{code-cell} ipython3
umath.isnan
```

```{code-cell} ipython3
from uncertainties import umath
# umath.isnan(B)
# B.pipe(umath.isnan)
unumpy.isnan(B)
```

```{code-cell} ipython3
B.where(~unumpy.isnan(B),0)
```

```{code-cell} ipython3
import hvplot.pandas
xePropsFit['Splitting/cm−1'].plot()
```

```{code-cell} ipython3
xePropsFit.index.values
```

```{code-cell} ipython3

```

```{code-cell} ipython3
# xePropsFit['Splitting/cm−1'].hvplot()  # No multindex support...?

# Ah, probably need to flatten - should have code elsewhere for this.
# Quick go per https://stackoverflow.com/questions/74860179/hvplot-interactive-pd-dataframe-with-multiindex
# Fails for Series... except with names only... can't recall how to fix this right now...
dataPlot = xePropsFit['Splitting/cm−1'].set_axis(map(" ".join, xePropsFit.index.names), axis=0)
# dataPlot = xePropsFit['Splitting/cm−1'].set_axis(map(" ".join, qnDF.columns), axis=0)

# qnDF['F']
# dataPlot = xePropsFit.set_axis(map(" ".join, xePropsFit.index.values), axis=1)
dataPlot.hvplot()
```

```{code-cell} ipython3
(xePropsFit.loc[(129), 'Splitting/cm−1']/xePropsFit.loc[(129)].index.to_frame()['F′']).values
```

```{code-cell} ipython3
# xePropsFit.loc[(129)].index[0]
xePropsFit.loc[(129)].index.to_frame()['F']
```

```{code-cell} ipython3
xeProps
```

## SCRATCH

```{code-cell} ipython3
xeProps['A/MHz']
```

```{code-cell} ipython3
xeProps.xs((131,1.5,1.5,0.5))
```

```{code-cell} ipython3
xeProps.to_xarray()
```

```{code-cell} ipython3

```
