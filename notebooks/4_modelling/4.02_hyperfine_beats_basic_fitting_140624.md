---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.14.7
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Basic fitting for hyperfine beat (stage 1 bootstrap)

From prior work and data:

- Forbes, R. et al. (2018) ‘Quantum-beat photoelectron-imaging spectroscopy of Xe in the VUV’, Physical Review A, 97(6), p. 063417. Available at: https://doi.org/10.1103/PhysRevA.97.063417. arXiv: http://arxiv.org/abs/1803.01081, Authorea (original HTML version): https://doi.org/10.22541/au.156045380.07795038
- Data (OSF): https://osf.io/ds8mk/
- [Quantum Metrology with Photoelectrons (Github repo)](https://github.com/phockett/Quantum-Metrology-with-Photoelectrons), particularly the [Alignment 3 notebook](https://github.com/phockett/Quantum-Metrology-with-Photoelectrons/blob/master/Alignment/Alignment-3.ipynb). Functions from this notebook have been incorporated in the current project, under `qbanalysis.hyperfine`.

+++

For basic fitting, try a stage 1 style bootstrap. In this case, set (arbitrary) parameters per final state for the probe, and fit these plus the hyperfine beat model parameters. This should allow for a match to a single set of hyperfine parameters for all observables.

- 14/06/24: basic fit for L=4/ROI-0 data working with Scipy. Next should add ionization model and use all states...
   - Xarray wrapper may be neater? See https://docs.xarray.dev/en/latest/generated/xarray.DataArray.curvefit.html#xarray.DataArray.curvefit
   - 16/06/24: A,B param determination with Scipy.least_squares working. Seems like overkill, but other methods not very flexible? Currently pass Xarray data for calcs, with wrappers for Scipy. Quite annoying.
   - TODO: try PD-based calc, should actually be easier in this case.

+++

## Setup fitting model

Follow the modelling notebook, but wrap functions for fitting.

New functions are in `qbanalysis.basic_fitting.py`.

+++

### Imports

```{code-cell} ipython3
# Load packages
# Main functions used herein from qbanalysis.hyperfine
from qbanalysis.hyperfine import *
import numpy as np
from epsproc.sphCalc import setBLMs

from pathlib import Path

dataPath = Path('/tmp/xe_analysis')
# dataTypes = ['BLMall', 'BLMerr', 'BLMerrCycle']   # Read these types, should just do dir scan here.

# # Read from HDF5/NetCDF files
# # TO FIX: this should be identical to loadFinalDataset(dataPath), but gives slightly different plots - possibly complex/real/abs confusion?
# dataDict = {}
# for item in dataTypes:
#     dataDict[item] = IO.readXarray(fileName=f'Xe_dataset_{item}.nc', filePath=dataPath.as_posix()).real
#     dataDict[item].name = item

# Read from raw data files
from qbanalysis.dataset import loadFinalDataset
dataDict = loadFinalDataset(dataPath)

# Use Pandas and load Xe local data (ODS)
# These values were detemermined from the experimental data as detailed in ref. [4].
from qbanalysis.dataset import loadXeProps
xeProps = loadXeProps()
```

### Init parameters & test

Here use `xeProps` to set and define fit paramters. Note in the original work the splittings were determined by FT of the data, and A, B parameters via Eqn. 2 therein.

TODO: may want to use lmfit here for more flexibility.

```{code-cell} ipython3
# Set splittings
fitParamsCol = 'Splitting/cm−1'
xePropsFit = xeProps.copy()

xeSplittings = xePropsFit[fitParamsCol].to_numpy()
```

```{code-cell} ipython3
# # Test beat model with changed params...
# xeSplittings = np.random.randn(4)
# xeSplittings
```

```{code-cell} ipython3
# xePropsFit[fitParamsCol] = 0.1*np.abs(xeSplittings)
# xePropsFit
```

```{code-cell} ipython3
# Test beat model with changed params...

# Set arb params
xeSplittings = np.random.randn(4)
xePropsFit[fitParamsCol] = 0.1*np.abs(xeSplittings)

# Compute model with new params
modelDict = computeModel(xePropsFit)
modelDictSum, modelDA = computeModelSum(modelDict)

# Plot model
plotOpts = {'width':800}
modelDA = stackModelToDA(modelDictSum)
plotHyperfineModel(modelDA, **plotOpts).opts(title="Isotope comparison + sum")
```

## Run fits with Scipy Least Squares

Use the wrapper :py:func:`qbanalysis.basic_fitting.calcFitModel()` with `scipy.optimize.least_squares`. The wrapper uses `computeModelSum()` as above, and computes the residuals.

For the basic case, no ionization model is included, so this fit is only to see how well the form of the hyperfine beat can be matched to the  $K=4$ case for ROI 0, and how much the level splittings are modified from the previous case (determined by FT).

```{code-cell} ipython3
# Import functions
from qbanalysis.basic_fitting import *
import scipy

#*** Init params - either random or from previous best
# NOTE: this needs to be a 1D Numpy array.
# x0 = np.abs(np.random.random(4))  # Randomise inputs

# Seed with existing params - note this can't be Uncertainties objects
xePropsFit = xeProps.copy()
x0 = unumpy.nominal_values(xePropsFit[fitParamsCol].to_numpy())  # Test with previous vals

#*** Run a fit
fitOut = scipy.optimize.least_squares(calcBasicFitModel, x0, bounds = (0.01,0.5), verbose = 2,
                                      kwargs = {'xePropsFit':xePropsFit, 'dataDict':dataDict})
fitOut.success
```

```{code-cell} ipython3
# Using Scipy, the fit details are in fitOut, and results in fitOut.x
fitOut.x
```

```{code-cell} ipython3
fitOut
```

```{code-cell} ipython3
# Check results - run model again with best fits
xePropsFit, modelFit, modelFitSum, modelIn, dataIn, res = calcBasicFitModel(fitOut.x, xePropsFit, dataDict, fitFlag=False)

# Fitted model & components
# (plotHyperfineModel(modelFit['129Xe'], **plotOpts) * plotHyperfineModel(modelFit['131Xe'], **plotOpts) * plotHyperfineModel(modelFitSum, **plotOpts)).opts(title="Isotope comparison + sum")

# Compare fit results with dataset
from qbanalysis.plots import plotFinalDatasetBLMt
# plotFinalDatasetBLMt(**dataDict, **plotOpts) * plotHyperfineModel(modelFitSum, **plotOpts).select(K=2).opts(**plotOpts)
(plotHyperfineModel(modelFitSum, **plotOpts,).select(K=2).opts(**plotOpts) * plotFinalDatasetBLMt(**dataDict, **plotOpts).select(l=4)).opts(title="Fit (K=2) plus data (l=4)")
```

```{code-cell} ipython3
# Check new results vs. reference case...
compareResults(xeProps, xePropsFit)
```

Here we can see that - as expected - the fit is pretty good for the $l=4$, $ROI=0$ data. The fitted values are slightly different to the previous results (obtained via FT of the time-domain data).

+++

## Determine A & B parameters

To further compare these new splittings with the previous results and literature, the A & B hyperfine parameters can be determined.

From the measurements, the hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
\begin{equation}
\Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
\end{equation}

Note, for $^{129}\rm{Xe}$, $\Delta E_{(F,F-1)}=AF$ only ($B=0$).

```{code-cell} ipython3
extractABParams(xePropsFit)
```

```{code-cell} ipython3
xePropsFit
```

```{code-cell} ipython3
# # Fix splitting value (derived) - NOW IN MAIN ROUTINE
# iso=131
# xePropsFit.loc[(iso,1.5,2.5,1.5), dataCol] = xePropsFit.loc[(iso,1.5,2.5,0.5), dataCol] - xePropsFit.loc[(iso,1.5,1.5,0.5), dataCol]
# xePropsFit
```

```{code-cell} ipython3
break
```

### Determine A & B parameters

Previously fitted in Matlab with cffit tool, see `jake-home/tmp/xe_analysis_2024_scratch/Xe_hyperfine_cftool_fit_code_041217.m`.

+++

From the measurements, the hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
\begin{equation}
\Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
\end{equation}

Note, for $^{129}\rm{Xe}$, $\Delta E_{(F,F-1)}=AF$ only ($B=0$).

+++

### Quick test with sklearn (linear)

```{code-cell} ipython3
# Xe129, dE(F,F-1)=AF
# xePropsFit[[xePropsFit.xs((129)),'A/MHz']]  #['A/MHz']= 30

cmToMHz = 29979.2458
dataCol = 'Splitting/cm−1'
qnDF = xePropsFit.loc[(129)].index.to_frame()  # Convert to DF for easy Q.N./index value retrieval
xePropsFit.loc[(129), 'A/MHz'] = (xePropsFit.loc[(129), dataCol]/qnDF['F′']).values * cmToMHz
xePropsFit                                                                                                         
```

```{code-cell} ipython3
xePropsFit.xs(131)[dataCol]
```

```{code-cell} ipython3
xePropsFit.xs(iso)[dataCol].to_numpy()
```

```{code-cell} ipython3
qnDF['F'].to_numpy()
```

```{code-cell} ipython3
# Xe131
iso=131
qnDF = xePropsFit.loc[(iso)].index.to_frame()  # Convert to DF for easy Q.N./index value retrieval

# Fix splitting value (derived)
xePropsFit.loc[(iso,1.5,2.5,1.5), dataCol] = xePropsFit.loc[(iso,1.5,2.5,0.5), dataCol] - xePropsFit.loc[(iso,1.5,1.5,0.5), dataCol]
xePropsFit


# Quick test with linear regression
# https://realpython.com/linear-regression-in-python/
# Probably want scipy.curve_fit here though, with function defined.
from sklearn.linear_model import LinearRegression
model = LinearRegression()

# Quick test, only need 2 of these values, but should be more careful here...!
x=qnDF['F'][0:2].to_numpy().reshape(-1,1)
y=xePropsFit.xs(iso)[dataCol][0:2].to_numpy()
model.fit(x,y)
r_sq = model.score(x, y)
print(f"coefficient of determination: {r_sq}")
print(f"intercept: {model.intercept_}")
print(f"slope: {model.coef_}")

# TODO: check old work for method (not in Matlab code...?)
# TODO: other methods? Scipy or Xarray...?
# https://docs.xarray.dev/en/latest/generated/xarray.DataArray.curvefit.html#xarray.DataArray.curvefit
```

### v3 - just use PD...

```{code-cell} ipython3
xePropsFit
```

```{code-cell} ipython3
# Now in basic_fitting code

# # xeProps.unstack(['I','F','F′'])  #['I']
# dataPD = xeProps.reset_index()  # Unstack to cols for calculation

# A = 5700
# B = 10

# def dEcalc(dataInPD, A, B):
#     """
#     Calculate dE from A & B
    
#     The hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
#     \begin{equation}
#     \Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
#     \end{equation}
    
#     NOTE: units currently set for return values only.
#     NOTE: this version assumes PD dataframe input. Multiindex including [Isotope,I,F], or columns OK.
    
#     """
#     # Set units
#     units = 'cm-1'
#     cmToMHz = 29979.2458

#     # Set J
#     J=1
    
#     # Set data - note reset index to just use col values
#     dataPD = dataInPD.copy()
#     if 'I' not in dataPD.columns:
#         dataPD = dataPD.reset_index()
        
        
#     I=dataPD['I']
#     c1=0.5-J*(J+1)-I*(I+1)
#     c2=I*J*(2*J-1)*(2*I-1)
#     F = dataPD['F']
#     t1 = A*F 
#     t2 = (3/2)*B*((F**2 + c1)/c2)
#     t2 = t2.fillna(0)

#     dataOut = dataPD.copy()
    
#     #*** Set outputs by isotope and dF
#     # Default case, t1 only
#     dataOut['dE'] = t1
    
#     # For 131Xe, use t1+t2
#     dataOut.loc[dataOut['Isotope']==131,'dE'] = (t1+t2)
    
#     # ...and replace cases with dF > 1
#     dataOut.loc[np.abs(dataOut['F'] - dataOut['F′'])>1, 'dE'] = np.nan
    
#     # Cheat here, and replace with sum for known case - should automate this!
#     # Note use of .values otherwise data with Uncertainties may not propagate correctly.
#     dataOut.loc[(dataOut['Isotope']==131) & (dataOut['F']==2.5) & (dataOut['F′']==0.5),'dE'] = dataOut[(dataOut['Isotope']==131) & (dataOut['F']==2.5) & (dataOut['F′']==1.5)]['dE'].values + dataOut[(dataOut['Isotope']==131) & (dataOut['F']==1.5) & (dataOut['F′']==0.5)]['dE'].values

    
#     # Set units
#     if units == 'cm-1':
#         dataOut['dE'] = dataOut['dE']*(1/cmToMHz)
    

#     return dataOut

# dataOut = dEcalc(xePropsFit, dataPD['A/MHz'], dataPD['B/MHz'])

# dataOut
```

```{code-cell} ipython3
unumpy.nominal_values(dataOut['Splitting/cm−1'] - dataOut['dE'])
```

```{code-cell} ipython3
dataOut
```

```{code-cell} ipython3
dEcalcWrapperScipy([2000,30],xeDataInPD=data131)
```

```{code-cell} ipython3
data131 = xePropsFit.reset_index()
data131 = data131.loc[data131['Isotope']==131]
data131
```

```{code-cell} ipython3
# Now in basic fitting code

# def dEcalcWrapperScipy(x0,xeDataInPD=None):
#     """
#     Wrap dEcalc for Scipy least_squares...
#     """
    
#     dEOut = dEcalc(xeDataInPD, x0[0], x0[1])
    
#     res = ((dEOut['Splitting/cm−1'] - dEOut['dE'])**2) #.squeeze()
    
#     if unFlag:
#         res = unumpy.nominal_values(res)
    
#     return res

# # Set data to fit - NOTE 131 only!
# data131 = xePropsFit.reset_index()   # Use reset here, xePropsFit.xs(131) drops index
# data131 = data131.loc[data131['Isotope']==131]


# # x0in = np.random.rand(2)
# x0in = [2000,30]

# fitOut = scipy.optimize.least_squares(dEcalcWrapperScipy, x0in, bounds = ([0,-100],[2500,100]),
#                                       kwargs = {'xeDataInPD':data131},
#                                       verbose = 2,
#                                       xtol=1e-12,ftol=1e-12,gtol=1e-18)
```

```{code-cell} ipython3
fitOut
```

```{code-cell} ipython3
fitOut.x
```

```{code-cell} ipython3
dOut = dEcalc(data131, *fitOut.x)
dOut
```

```{code-cell} ipython3
dataCols = xePropsFit.reset_index()   # Use reset here, xePropsFit.xs(131) drops index
data129 = dataCols.loc[dataCols['Isotope']==129]

data129.append(dOut)  #.append
```

```{code-cell} ipython3
import pandas as pd
def extractABParams(xePropsFit):
    """
    Determine A & B parameters from hyperfine level splittings.
    
    This runs a quick fit with Scipy
    """
    
    #*** Set data to fit - NOTE 131 only!
    dataCols = xePropsFit.reset_index()   # Use reset here, xePropsFit.xs(131) drops index
    data131 = dataCols.loc[dataCols['Isotope']==131]

    #*** Extract A,B for 131Xe using Scipy fitting
    # x0in = np.random.rand(2)
    x0in = [2000,30]

    fitOut = scipy.optimize.least_squares(dEcalcWrapperScipy, x0in, bounds = ([0,-100],[2500,100]),
                                          kwargs = {'xeDataInPD':data131},
                                          verbose = 0,
                                          xtol=1e-12,ftol=1e-12,gtol=1e-18)
    
    # Set final results
    dataFit = dEcalc(data131, *fitOut.x)
    
    # Add fitted results to table
    dataFit['A/MHz'] = fitOut.x[0]
    dataFit['B/MHz'] = fitOut.x[1]
    
    # Add 129 case back in
    # Note phase = -1 by convention, since F<F' - now included in dE calc directly
    # phase =-1
    data129 = dataCols.loc[dataCols['Isotope']==129]
    
    # This works, but always throwing PD warning?
    # data129.loc[data129['Isotope']==129,'A/MHz']= data129['Splitting/cm−1']/data129['F′'] * cmToMHz
    cols = data129['Isotope']==129
    data129.loc[cols,'A/MHz'] = data129.loc[cols,'Splitting/cm−1']/data129.loc[cols,'F′'] * cmToMHz 
    # data129.loc[cols,'dE'] = data129.loc[cols,'F′'] * data129.loc[cols,'A/MHz'] * 1/cmToMHz
    
    data129 = dEcalc(data129, data129['A/MHz'], np.nan)
    
    # data129.loc[data129.columns['A/MHz']]
    # dF = xeData.F - xeData['F′']
    dataOut = pd.concat([data129,dataFit])
    
    return dataOut
```

```{code-cell} ipython3
dataCols['F']- dataCols['F′']
```

```{code-cell} ipython3
extractABParams(xePropsFit)
```

```{code-cell} ipython3
Iind = dataCols['Isotope']
dataCols.loc[Iind==129,'A/MHz']=data129['Splitting/cm−1']/data129['F′']
```

```{code-cell} ipython3
dataCols
```

```{code-cell} ipython3
data129.loc[,'A/MHz']=data129['Splitting/cm−1']/data129['F′']  #).values
data129
```

```{code-cell} ipython3
dataOut.columns
```

```{code-cell} ipython3
np.abs(dataOut['F'] - dataOut['F′'])>1
```

```{code-cell} ipython3
dataOut[np.abs(dataOut['F'] - dataOut['F′'])>1]
```

### Use Xarray wrapper - should be easier... V2: extract from PD, then XR

```{code-cell} ipython3
# xeData = xePropsFit.to_xarray()

# xePropsFit.s
dataCol = 'Splitting/cm−1'
xePropsFit.xs(131)[dataCol]
# unstack .to_xarray()
```

```{code-cell} ipython3
# dEXR.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}]
```

```{code-cell} ipython3
# NEW APPROACH - set up specific DA for fitting...
# THIS will return required vals only.
xeSubSel = xePropsFit.xs(131)[dataCol][0:2].droplevel('F′').to_xarray()  # for f' too?
A = xePropsFit.xs(131)['A/MHz'][0:2].droplevel('F′').to_xarray()
B = xePropsFit.xs(131)['B/MHz'][0:2].droplevel('F′').to_xarray()

dESubSel = dEv2(xeSubSel,A,B)
dESubSel
```

```{code-cell} ipython3
xeSubSel.squeeze().hvplot()
```

```{code-cell} ipython3
xeSubSel.squeeze() - dESubSel
```

```{code-cell} ipython3
# With Scipy wrapper... test return OK...
print(dEv2WrapperScipy([2000,0],xeDataIn=xeSubSel))
print(dEv2WrapperScipy([1697,0],xeDataIn=xeSubSel))
print(dEv2WrapperScipy([1697,-8],xeDataIn=xeSubSel))
```

```{code-cell} ipython3
# # Ah, can't pass additional args to curvefit in any case...????
# dsFit = dESubSel.curvefit(

#     coords=dESubSel.F,
    
#     # reduce_dims="I",

#     func=dEv2Wrapper,

#     bounds={"A": (1000, 2000), "B": (-15, 15)},
    
#     param_names=["A","B"],
    
#     kwargs={'xeDataIn':dESubSel}

# )

# USE WRAPPER FOR SCIPY DIRECTLY... WORKING...
#
# Defaults give [1718.15579161,   -2.19752871], [1663.67627212,    4.42848128], [ 1.69247409e+03, -1.49524345e-01]
# Seems more dependent on x0in than tolerances...? Could do with more points?
# Sets B to ~0 if bounded at 0, so -ve definitely good it seems, although not well defined?
#
# UPDATE: had mixed new and old values... now fixed...
#  [1729.31918052,   37.13028214]  # Seems pretty consistent vs. x0in.
#
# x0in = [2000,0]
# x0in = [1500, 0]
x0in = np.random.rand(2)

fitOut = scipy.optimize.least_squares(dEv2WrapperScipy, x0in, bounds = ([0,-100],[2500,100]),
                                      kwargs = {'xeDataIn':xeSubSel},
                                      verbose = 2,
                                      xtol=1e-12,ftol=1e-12,gtol=1e-18)
```

```{code-cell} ipython3
fitOut
```

```{code-cell} ipython3
fitOut.x
```

```{code-cell} ipython3
# 17/06/24: now in basic_fitting.py

# # V2, testing subselected PD array > Xr
# # Calculate dE for Xarray input - in this case all coords should match in size...
# # A,B can be Xarray or scalar
# # def dEv2(xeDataIn, A, B, units = 'cm-1'):
# def dEv2(xeDataIn, A, B):
#     """
#     the hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
#     \begin{equation}
#     \Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
#     \end{equation}
    
#     NOTE: units currently set for return values only.
#     """
#     # for iso in xeData.Isotope:
#     #     print(item)
#     units = 'cm-1'
#     cmToMHz = 29979.2458
    
#     # Isotope terms
#     J=1
#     I=xeDataIn.I
#     c1=0.5-J*(J+1)-I*(I+1)
#     c2=I*J*(2*J-1)*(2*I-1)
    
#     # A/B terms
#     F = xeDataIn.F
#     # F = xeData['F′']  # TODO: fix 129 ordering, needs F,F' swapped! (Or enforce selection here...)
#                         # Or swap on max value, or unique values... 
#                         # Or check on dF, xeData.F - xeData['F′'] ...?
#     # This works, but have some redundant values still
#     # Ffixed = xr.where(xeData.F > xeData['F′'], xeData.F, xeData['F′'])  # Check greater
#     # F = Ffixed[:,1]
    
#     # Try unique vals only... Breaks 129 case...
#     # F = xeData.F.where(xeData.F > 1)
    
#     # Deltas... filter on these at return?
#     # dF = xeData.F - xeData['F′']
    
    
#     t1 = A*F  #* np.sign(dF)
    
#     # For Xr case avoid Nan propagation
#     if isinstance(B, xr.DataArray):
#         if unFlag:
#             B = xrUnFillna(B)
#         else:
#             B = B.fillna(0)
        
        
#     t2 = (3/2)*B*((F**2 + c1)/c2)
#     t2 = t2.fillna(0)
    
#     # return t1,t2,t1+t2
    
#     if units == 'MHz':
#         dEout = t1+t2
#     elif units == 'cm-1':
#         dEout = (t1+t2)*(1/cmToMHz)

#     # Check allowed terms...?
#     # dEout = dEout.where(np.abs(dF)<2,np.nan)
        
        
#     # TODO: general fix for F-F' > 1..?
#     # dEXR.where(dEXR.F - dEXR['F′'] > 1)
#     # Quick fix here for Xe131 case only
#     # dEout.sel({'F':
#     # dEout.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}] = dEout.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEout.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
    
#     if unFlag:
#         dEout.values = unumpy.nominal_values(dEout)
        
#     return dEout


# def dEv2Wrapper(xeDataInNP, A, B, xeDataIn):
#     """
#     Thin wrapper for xr.curvefit.
    
#     Just swap NP data as passed for XR data to use existing function
#     """
    
#     dEOut = dEv2(xeDataIn, A, B)
    
#     return dEout

    
# def dEv2WrapperScipy(x0,xeDataIn=None):
#     """
#     ... and wrap for Scipy least_squares...
#     """
    
#     dEOut = dEv2(xeDataIn, x0[0], x0[1])
    
#     res = ((xeDataIn - dEOut)**2).squeeze()
    
#     return res.values

    
# def xrUnFillna(xrData):
#     """
#     Implement xr.fillna for Uncertainties data types.
#     """
    
#     return xrData.where(~unumpy.isnan(xrData),0)
```

### Use Xarray wrapper - should be easier... V1: pure Xr, lots of redun

```{code-cell} ipython3
xeData = xePropsFit.to_xarray()
xeData
```

```{code-cell} ipython3
xeData.F
```

```{code-cell} ipython3
# 17/06/24: now in basic_fitting.py

# # V1, assumes full PD array > Xr
# # Calculate dE for Xarray input - in this case all coords should match in size...
# # A,B can be Xarray or scalar
# def dE(xeDataIn, A, B, units = 'cm-1'):
#     """
#     the hyperfine coupling constants can be determined by fitting to the usual form (see, e.g., ref. \cite{D_Amico_1999}):
#     \begin{equation}
#     \Delta E_{(F,F-1)}=AF+\frac{3}{2}BF\left(\frac{F^{2}+\frac{1}{2}-J(J+1)-I(I+1)}{IJ(2J-1)(2I-1)}\right)
#     \end{equation}
    
#     NOTE: units currently set for return values only.
#     """
#     # for iso in xeData.Isotope:
#     #     print(item)
#     cmToMHz = 29979.2458
    
#     # Isotope terms
#     J=1
#     I=xeDataIn.I
#     c1=0.5-J*(J+1)-I*(I+1)
#     c2=I*J*(2*J-1)*(2*I-1)
    
#     # A/B terms
#     # F = xeDataIn.F
#     # F = xeData['F′']  # TODO: fix 129 ordering, needs F,F' swapped! (Or enforce selection here...)
#                         # Or swap on max value, or unique values... 
#                         # Or check on dF, xeData.F - xeData['F′'] ...?
#     # This works, but have some redundant values still
#     Ffixed = xr.where(xeData.F > xeData['F′'], xeData.F, xeData['F′'])  # Check greater
#     F = Ffixed[:,1]
    
#     # Try unique vals only... Breaks 129 case...
#     # F = xeData.F.where(xeData.F > 1)
    
#     # Deltas... filter on these at return?
#     dF = xeData.F - xeData['F′']
    
    
#     t1 = A*F* np.sign(dF)
    
#     # For Xr case avoid Nan propagation
#     if isinstance(B, xr.DataArray):
#         if unFlag:
#             B = xrUnFillna(B)
#         else:
#             B = B.fillna(0)
        
        
#     t2 = (3/2)*B*((F**2 + c1)/c2)
#     t2 = t2.fillna(0)
    
#     # return t1,t2,t1+t2
    
#     if units == 'MHz':
#         dEout = t1+t2
#     elif units == 'cm-1':
#         dEout = (t1+t2)*(1/cmToMHz)

#     # Check allowed terms...?
#     dEout = dEout.where(np.abs(dF)<2,np.nan)
        
        
#     # TODO: general fix for F-F' > 1..?
#     # dEXR.where(dEXR.F - dEXR['F′'] > 1)
#     # Quick fix here for Xe131 case only
#     # dEout.sel({'F':
#     # dEout.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}] = dEout.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEout.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
    
    
#     return dEout

# def xrUnFillna(xrData):
#     """
#     Implement xr.fillna for Uncertainties data types.
#     """
    
#     return xrData.where(~unumpy.isnan(xrData),0)
```

```{code-cell} ipython3
Ffixed = xr.where(xeData.F > xeData['F′'], xeData.F, xeData['F′'])
Ffixed[:,1]
```

```{code-cell} ipython3
xeData.F.where(xeData.F > 1)
```

```{code-cell} ipython3
dF = xeData.F - xeData['F′']
xeData.where(np.abs(dF)<2,0)
dF
```

```{code-cell} ipython3
xeData.F
```

```{code-cell} ipython3
dE(xeData,3,10)
```

```{code-cell} ipython3
isinstance(xeData['B/MHz'], xr.DataArray)
```

```{code-cell} ipython3
dEXR = dE(xeData, xeData['A/MHz'], xeData['B/MHz'])

dEXR  #.sel(Isotope=129)
```

```{code-cell} ipython3
# Reduce to only required dim for fitting...
dEsub = dEXR.loc[{'Isotope':131,'F':[1.5,2.5],'I':1.5}]  #.dropna()

# dEsub.hvplot.line(x='F')
```

```{code-cell} ipython3
# dEXR.sel({'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}) = dEXR.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEXR.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
dEXR.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}] = dEXR.sel({'Isotope':131,'F':1.5,'F′':0.5, 'I':1.5}) + dEXR.sel({'Isotope':131,'F':2.5,'F′':1.5, 'I':1.5})
```

```{code-cell} ipython3
dEXR.loc[{'Isotope':131, 'I':1.5}].drop('F′')
```

```{code-cell} ipython3
Ffixed
```

```{code-cell} ipython3
dEXR.loc[{'Isotope':131,'F':2.5,'F′':0.5, 'I':1.5}]
```

```{code-cell} ipython3
dEXR.sel({'Isotope':131,'I':1.5},drop=True) #.flatten()  #.dropna()
```

```{code-cell} ipython3
dEXR.where(dEXR.F - dEXR['F′'] > 1)
```

```{code-cell} ipython3
dE(xeData,0,0)
```

```{code-cell} ipython3
F = xeData.F
xeData['A/MHz'] * F
```

```{code-cell} ipython3
B = xeData['B/MHz']

J=1
I=xeData.I
c1=0.5-J*(J+1)-I*(I+1)
c2=I*J*(2*J-1)*(2*I-1)

# For Xr case avoid Nan propagation
if isinstance(B, xr.DataArray):
    B = B.fillna(0)

t2 = (3/2)*B*((F**2 + c1)/c2)
t2 = t2.fillna(0)
t2
```

```{code-cell} ipython3
# B
# uncertainties.umath.isnan(B)
unumpy.nominal_values(B)
```

```{code-cell} ipython3
xeData.sel(Isotope=131)['F']
```

```{code-cell} ipython3
xeData.where(F>0.5)
```

```{code-cell} ipython3
xeData.sel(Isotope=129)['F′']
```

```{code-cell} ipython3
umath.isnan
```

```{code-cell} ipython3
from uncertainties import umath
# umath.isnan(B)
# B.pipe(umath.isnan)
unumpy.isnan(B)
```

```{code-cell} ipython3
B.where(~unumpy.isnan(B),0)
```

```{code-cell} ipython3
import hvplot.pandas
xePropsFit['Splitting/cm−1'].plot()
```

```{code-cell} ipython3
xePropsFit.index.values
```

```{code-cell} ipython3

```

```{code-cell} ipython3
# xePropsFit['Splitting/cm−1'].hvplot()  # No multindex support...?

# Ah, probably need to flatten - should have code elsewhere for this.
# Quick go per https://stackoverflow.com/questions/74860179/hvplot-interactive-pd-dataframe-with-multiindex
# Fails for Series... except with names only... can't recall how to fix this right now...
dataPlot = xePropsFit['Splitting/cm−1'].set_axis(map(" ".join, xePropsFit.index.names), axis=0)
# dataPlot = xePropsFit['Splitting/cm−1'].set_axis(map(" ".join, qnDF.columns), axis=0)

# qnDF['F']
# dataPlot = xePropsFit.set_axis(map(" ".join, xePropsFit.index.values), axis=1)
dataPlot.hvplot()
```

```{code-cell} ipython3
(xePropsFit.loc[(129), 'Splitting/cm−1']/xePropsFit.loc[(129)].index.to_frame()['F′']).values
```

```{code-cell} ipython3
# xePropsFit.loc[(129)].index[0]
xePropsFit.loc[(129)].index.to_frame()['F']
```

```{code-cell} ipython3
xeProps
```

## SCRATCH

```{code-cell} ipython3
xeProps['A/MHz']
```

```{code-cell} ipython3
xeProps.xs((131,1.5,1.5,0.5))
```

```{code-cell} ipython3
xeProps.to_xarray()
```

```{code-cell} ipython3

```
